import pandas as pd
import textwrap
import os

class METALToolkit():
    """a class for python preparing/processing METAL's meta analysis

    This class intake dataFrame from association table generated by
    ...pipeline.association.SNPAssociation instance and provides the following APIs:

    Initialize:
        mtk = METALToolkit(ethnicity = ["EU", "AF", "HISP"], verbose = 1)
            ethnicity: the name of ethnicities need to be analyzed
            verbose: 0 or 1, if 1, API internally reading or writing files will
                print a hint

    One-line final:
        mtk.path_to_metal(path)
            Prepare a METAL format folder from existing folder.
            This API requires the csv file in this folder should be in
            "ethnicity=*.csv" format, where * is the ethnicity specified in args
            it run mtk.csv_to_metal on each ethnicity=*.csv, and call
            mtk.generate_metal_script generate a metal_script.txt in the folder
    Sub-step APIs:
        mtk.dataframe_to_metal(df):
            Prepare a METAL format DataFrame from existing DataFrame instance:
        mtk.csv_to_metal(path)
            Prepare a METAL format CSV file from existing CSV file
        mtk.generate_metal_script(path)
            Prepare a METAL script with specified ethnicity:
            always returns a string, if path given, it will be saved to the path as well
    Post-processing:
        mtk.aggregate_result(path):
            After running the METAL analysis, this API will generate an
            aggregate table for this folder for next step analysis
    """
    def __init__(self, ethnicity = ["EU", "AF", "HISP"], verbose = 1):
        """initializer save the ethnicity setting,
        Args:
            ethnicity: list, the list of ethnicities in string format,
                        if not provided, using ["eu", "af", "hisp"]
            verbose: int, the verbosity running the pipeline
        """
        self._ethnicity = ethnicity
        self._verbose = verbose
#--------------------------prepare the metal table------------------------------
    def dataframe_to_metal(self, df):
        """for a given association DataFrame, prepare a METAL accepted version

        Args:
            df: pandas.DataFrame, an association table generated by
                ...pipeline.association.SNPAssociation instance
        Returns:
            df_new: pandas.DataFrame, an tidied version of association table
                ready for METAL's meta analysis
        """
        df_new = pd.DataFrame()
        df_new["SNP"] = df["snp_pos"].apply(self._get_pos)
        df_new["REF_ALLELE"] = df["snp_pos"].apply(lambda i: i.split("-")[-1]).apply(lambda i:i.split("/")[0])
        df_new["ALT_ALLELE"] = df["snp_pos"].apply(lambda i: i.split("-")[-1]).apply(lambda i:i.split("/")[-1])
        df_new["FREQ"] = df["rel_freqs"]
        df_new["BETA"] = df["snp_pos Beta"]
        df_new["SE"] = df["snp_pos SE"]
        df_new["PVAL"] = df["snp_pos P-value"]
        df_new["TOTAL"] = df["n_sample"]
        df_new["COUNT"] = df["abs_freqs"]
        df_new["POS-REF/ALT"] = df["snp_pos"]
        return df_new

    def csv_to_metal(self, path: str):
        """API including the csv file reading and writing

        Args:
            path: string, the path of an association table generated by
                ...pipeline.association.SNPAssociation instance
        Saves:
            csv file with an additional "_for_metal" at the end of the file name
        """
        df = pd.read_csv(path).rename(columns = {"Unnamed: 0": "snp_pos"})
        df_new = self.dataframe_to_metal(df)
        new_path = path.replace(".csv", "_for_metal.csv")
        df_new.to_csv(new_path, index = False)
        if self._verbose == 1:
            print(f"{new_path} saved")

    def path_to_metal(self, path: str):
        """API processing all the tables at once in a folder

        Args:
            path: string, the path of a folder with results "ethnicity=**.csv"s
        Saves:
            csv files with an additional "_for_metal" at the end of the file name
            a "metal_script.txt" for metal running
        """
        file_list = [os.path.join(path,f"ethnicity={i}.csv") for i in self._ethnicity]
        for tables in tqdm(file_list):
            self.csv_to_metal(tables)
        self.generate_metal_script(path = os.path.join(path, "metal_script.txt"))

#--------------------------prepare the metal script-----------------------------
    def generate_metal_script(self, path = None):
        """API generate the metal script for the meta analysis,

        Args:
            path: Optional[string], if given, it will save the script generated
                  to the path given as well
        Returns:
            script: string, the script for running the meta analysis
        """
        script =  "\n".join([self._metal_script_header(),
                      self._metal_script_description(),
                      self._metal_script_analyze()])
        if not path is None:
            with open(path, "w") as openfile:
                openfile.write(script)
            if self._verbose == 1:
                print(f"a METAL script is saved to {path}")
        return script

    def _metal_script_header(self):
        """prepare a header for the metal script"""
        return textwrap.dedent("""\
        SEPARATOR  COMMA
        # Meta-analysis weighted by standard error does not work well
        # when different studies used very different transformations.
        # In this case, some attempt was made to use similar trait
        # transformation and you can request a standard error based
        # analysis by uncommenting the following line:
        SCHEME   STDERR

        # Usually, it is a good to apply genomic control to each
        # input file. However, in this example, all the markers being
        # examined reside in strongly associated loci and it probably
        # is not a good idea. To find out what happens if you turn
        # on genomic control, uncomment the following line.
        # GENOMICCONTROL ON

        # To help identify allele flips, it can be useful to track
        # allele frequencies in the meta-analysis. To enable this
        # capability, uncomment the following two lines.
        # AVERAGEFREQ ON
        # MINMAXFREQ ON

        # To restric meta-analysis to two previously reported SNPs
        # and summarize study specific results, uncomment the two
        # lines that follow.
        # ADDFILTER SNP IN (rs10830963,rs563694)
        # VERBOSE ON

        """)

    def _metal_script_description(self):
        """prepare the description part of METAL script"""
        return "\n".join([textwrap.dedent(f"""\
            # Describe and process the DGI input files

            MARKER   POS-REF/ALT
            ALLELE   REF_ALLELE ALT_ALLELE
            FREQ     FREQ
            EFFECT   BETA
            STDERR   SE
            PVAL     PVAL

            PROCESS ethnicity={ethnicity}_for_metal.csv
            """) for ethnicity in self.ethnicities])

    def _metal_script_analyze(self):
        """prepare the analyze part of METAL script"""
        return textwrap.dedent(f"""\
            # Execute meta-analysis
            ANALYZE
            """)

#---------------------aggregate_result the metal result-------------------------
    def _get_snp_pos_data(self, path: str, key: str):
        """for a folder, and a specific key, get the beta, se, pvalue and sample info, add suffix"""
        df = pd.read_csv(os.path.join(path, f"ethnicity={key}.csv"), index_col = 0)
        df = df[["snp_pos Beta", "snp_pos SE", "snp_pos P-value", "n_sample"]]
        df.columns = df.columns+f"_{key}"
        return df

    def _get_pos(self, snp_pos):
        """extract pos in integer from a string format pos-ref/alt"""
        return int(snp_pos.split("-")[0])

    def aggregate_result(self, path):
        """API combine all the results from a meta folder"""
        meta = pd.read_csv(os.path.join(path, "METAANALYSIS1.TBL"), sep = "\t",index_col = 0)
        test_list = [meta]+[self.get_snp_pos_data(path, key) for key in self._ethnicity]
        final = pd.concat(test_list, axis = 1, join = "outer")
        final = final.reset_index()
        final["pos"] = final["index"].apply(self._get_pos)
        return final.sort_values("pos").set_index("index").drop(columns="pos")
