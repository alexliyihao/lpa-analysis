:py:mod:`lpa_pipeline.metal_toolkit`
====================================

.. py:module:: lpa_pipeline.metal_toolkit

.. autoapi-nested-parse::

   The toolkit running METAL-related pipeline internally

   .. rubric:: Example

   The class should be initiated as follows::

       mtk = metal_toolkit.METALToolkit(
           ethnicity = ["EU", "AF", "HISP"],
           engine_list = ["Logit", "OLS"],
           verbose = 1,
           metal_path = "/mnt/mfs/cluster/bin/METAL/metal",
           snp_alias = "variant"
           )

   One-line Pipeline::

       mtk.run_metal(
           path_association = "/path/of/association/module/output",
           path_meta = "/path/of/meta_analysis/output")

   It internally does everything below:

       mtk.copy_tree(path_association = path_association, path_meta = path_meta)
           move all the file in path_association to path_meta,
           and properly arrange them by traits

       mtk.csv_to_metal(path)
           Prepare a METAL format CSV file from existing CSV file at <path>

       mtk.generate_metal_script(path)
           Prepare  metal.sh and metal_script.txt with specified ethnicity.

       subprocess("chmod +x metal.sh" & "metal source metal_script.txt")
           run METAL from the script generated

       mtk.aggregate_result(path):
           After running the METAL analysis, this API will generate an
           aggregate table for this folder for next step analysis

       pd.concat([path/aggregate.csv for path in sub_folders], axis = 0)
           concatenate all the aggregate.csv

       mtk.formatting_final_result(df, multi_line_header = False)
           format the aggregate.csv
           multi_line_header is a historical problem, use False is fine.
           Set to True will generate another header row.

       mtk.save_final_output(df,path = "path", multi_line_header = False)
           deals with a bug in pandas when using multi-line headers

   The ``multi_line_header`` only makes difference at the output header,
   it will create another header row, just for the visualization pipeline



Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   lpa_pipeline.metal_toolkit.METALToolkit




Attributes
~~~~~~~~~~

.. autoapisummary::

   lpa_pipeline.metal_toolkit.parser


.. py:class:: METALToolkit(ethnicity: List[str] = ['EU', 'AF', 'HISP'], engine_list: List[str] = ['OLS', 'Logit'], verbose: int = 1, metal_path: str = '/mnt/mfs/cluster/bin/METAL/metal', snp_alias: str = 'variant')


   Pipeline for python preparing/processing METAL's meta analysis

   .. py:method:: run_metal(path_association: str, path_meta: str, rename: bool = False, multi_line_header: bool = False) -> pandas.DataFrame

      API processing all the tables at once in a folder

      It will copy the path from <path_association> (keep an unaffected
      version) to <path_meta> (must not already exist!) and process
      everything in new path to

      :param path_association: str, the path of association outputs
      :param path_meta: str, the path to meta-analysis, it must not already exist.
      :param rename: boolean, using False is fine, just for formatting
      :param multi_line_header: boolean, using False is fine.

      :returns: an aggregate result for meta-analysis
      :rtype: pd.DataFrame

      Saves:
          in path_meta:
          - csv files with an additional "_for_metal" at the end of file name
          - metal.sh and metal_script.txt for metal running
          - aggregate.csv in each trait folder
          - aggregate_all_traits.xlsx in path_meta for better exploration.


   .. py:method:: dataframe_to_metal(df: pandas.DataFrame) -> pandas.DataFrame

      for a given association DataFrame, prepare a METAL accepted version

      :param df: pd.DataFrame, an association table generated by
      :param association.SNPAssociation instance:

      :returns: a tidied version of association table
                ready for METAL's meta analysis
      :rtype: pd.DataFrame


   .. py:method:: csv_to_metal(path: str)

      API including the csv file reading and writing

      :param path: string, the path of an association table generated by
      :param ...pipeline.association.SNPAssociation instance:

      Saves:
          csv file with an additional "_for_metal" at the end of the file name


   .. py:method:: generate_metal_script(path=None) -> None

      API generate the metal script for the meta analysis,

      :param path: Optional[string], if given, it will save the script generated
      :param to the path given as well:

      :returns: the script for running the meta analysis
      :rtype: str


   .. py:method:: _metal_script_header() -> str

      prepare a header for the metal script


   .. py:method:: _metal_script_description() -> str

      prepare the description part of METAL script


   .. py:method:: _metal_script_analyze()

      prepare the analysis part of METAL script


   .. py:method:: generate_metal_running_script(metal_path) -> str

      prepare the running script of METAL


   .. py:method:: _get_snp_data(path: str, key: str) -> pandas.DataFrame

      for a folder, and a specific key, get the requested info, add suffix


   .. py:method:: _get_pos(variant: str) -> int

      extract pos in integer from a string format pos-ref/alt


   .. py:method:: aggregate_result(path: str) -> pandas.DataFrame

      give a folder with METAL result, combine all the results


   .. py:method:: formatting_final_result(df: pandas.DataFrame, multi_line_header: bool = False, rename: bool = False) -> pandas.DataFrame


   .. py:method:: copy_tree(path_association: str, path_meta: str) -> None

      move file from path_association to path_meta, arrange by traits


   .. py:method:: save_final_output(df: pandas.DataFrame, path: str, multi_line_header: bool) -> None

      wrapper saving the output file, which is for solving a bug saving
      pd.DataFrame with multiIndex to excel,
      see https://stackoverflow.com/a/71305025.


   .. py:method:: _logging(log: str) -> None

      just for code cleaning...


   .. py:method:: _save_double_column_df(df: pandas.DataFrame, xl_writer: pandas.ExcelWriter, start_row: int = 0, **kwargs) -> None

      Function saving two-level column DataFrame to xlwriter
          credit to https://stackoverflow.com/a/71305025

      :param df: pd.DataFrame, the table to save
      :param xl_writer: pd.ExcelWriter, book for saving
      :param start_row: int, row from which dataframe will begin
      :param \*\*kwargs: Any, arguments of `to_excel` function of DataFrame`



.. py:data:: parser

   

